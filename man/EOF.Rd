% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EOF.R
\name{EOF}
\alias{EOF}
\title{Empirical Orthogonal Function}
\usage{
EOF(data, formula, value.var, n = 1)
}
\arguments{
\item{data}{a data.frame}

\item{formula}{formula passed to \code{\link[data.table]{dcast}} to build
the matrix that will be used in the SVD decomposition (see details)}

\item{value.var}{name of the column whose values will be used}

\item{n}{which singular values to return (if \code{NULL}, defaults to all)}
}
\value{
A list of 3 named elements containing tidy data.tables of the right and left
singular vectors, and of their explained variance.
}
\description{
Computes Singular Value Decomposition (also known as Principal Components
Analysis or Empirical Orthogonal Functions).
}
\details{
Singular values can be computed over matrices so \code{formula} denotes how
to build a matrix from the data. It is a formula of the form LHS ~ RHS in
which LHS represent the variables used to make the rows and RHS, the columns
of the matrix. The result of LHS ~ RHS and RHS ~ LHS (ie, terms reversed)
is the same, with the exception that the order of the singular vector is
reversed (right is left and left is right).

The variable combination used in this formula \emph{must} identify
an unique value in a cell. For the time being, no error will be raised, but
there will be a message from \code{\link[data.table]{dcast}}.

In the result, the \code{right} and \code{left} singular vectors have a
value for each singular value and each combination of the variables
used in RHS and LHS of \code{formula}, respectively.

It is much faster to compute only some singular vectors, so is advisable not
to set n to \code{NULL}. If the irba package is installed, EOF uses
\link[irlba:irlba]{irlba::irlba} instead of \link[base:svd]{base::svd} since it's much faster.
}
\examples{
# The Antarctic Oscillation is computed from the
# monthly geopotential height anomalies weigthed by latitude.
library(data.table)
aao <- copy(aao)
aao[, gh.t.w := Anomaly(gh)*sqrt(cos(lat*pi/180)),
      by = .(lon, lat, month(date))]
aao.svd <- EOF(aao, lat + lon ~ date, value.var = "gh.t.w", n = 1)

# AAO field
library(ggplot2)
ggplot(aao.svd$left, aes(lon, lat, z = value)) +
    geom_contour(aes(color = ..level..)) +
    coord_polar()

# AAO signal
ggplot(aao.svd$right, aes(date, value)) +
    geom_line()

# \% of explained variance
aao.svd$sdev

}
\seealso{
Other meteorology functions: \code{\link{DerivatePhysical}},
  \code{\link{Derivate}}, \code{\link{FitQsWave}},
  \code{\link{WaveFlux}}
}
