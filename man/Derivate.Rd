% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Derivate.R
\name{Derivate}
\alias{Derivate}
\alias{Laplacian}
\alias{Divergence}
\title{Derivate a discrete variable using finite differences}
\usage{
Derivate(formula, data = NULL, order = c(1, 2), cyclical = FALSE,
  sphere = FALSE, a = 6371000)

Laplacian(formula, data = NULL, cyclical = FALSE, sphere = FALSE,
  a = 6371000)

Divergence(formula, data = NULL, cyclical = FALSE, sphere = FALSE,
  a = 6371000)
}
\arguments{
\item{formula}{a formula indicating dependent and independent variables}

\item{data}{optional data.frame containing the variables}

\item{order}{order of the derivative}

\item{cyclical}{logical vector of boundary condition for each independent variable}

\item{sphere}{logical indicating whether to use spherical coordinates
(see details)}

\item{a}{radius for use in spherical coordinates (defaults to Earth's raduis)}
}
\value{
If there is one independent variable and one dependent variable, a numeric
vector of the same length as the dependent variable.
If there are two or more independent variables or two or more dependent variables,
a list containing the directional derivatives of each dependent variables.
}
\description{
Derivate a discrete variable using finite differences
}
\details{
Each element of the return vector is an estimation of \eqn{dx/dy} (or
\eqn{d^2x/dy^2} if \code{order} = 2) by centerd finite differences. The first and
last elements will be \code{NAs} unless cyclical boundary conditions are set
with \code{cyclical = TRUE}.

If \code{sphere = TRUE}, then the first two independent variables are
assumed to be longitude and latitude (\strong{in that order}) in degrees. Then, a
correction is applied to the derivative so that they are in the same units as
\code{a}.

\code{Laplacian()} and \code{Divergence()} are convenient wrappers that call \code{Derivate()}
and make the appropiate sums. For \code{Divergence()}, \code{formula} must be of the form
\code{vx + vy ~ x + y} (\strong{in that order}).
}
\examples{
theta <- seq(0, 360, length.out = 20)*pi/180
theta <- theta[-1]
x <- cos(theta)
dx_analytical <- -sin(theta)
dx_finitediff <- Derivate(x ~ theta, cyclical = TRUE)

plot(theta, dx_analytical, type = "l")
points(theta, dx_finitediff, col = "red")

# Curvature (Laplacian)
# Note the different boundary conditions for each dimension
variable <- expand.grid(lon = seq(0, 360, by = 3)[-1],
                        lat = seq(-90, 90, by = 3))
variable$z <- with(variable, cos(lat*pi/180*3) + sin(lon*pi/180*2))
variable <- cbind(variable,
                  as.data.frame(Derivate(z ~ lon + lat, data = variable,
                                        cyclical = c(TRUE, FALSE), order = 2)))
library(ggplot2)
ggplot(variable, aes(lon, lat)) +
    geom_contour(aes(z = z)) +
    geom_contour(aes(z = z.ddlon + z.ddlat), color = "red")

The same as
ggplot(variable, aes(lon, lat)) +
    geom_contour(aes(z = z)) +
    geom_contour(aes(z = Laplacian(z ~ lon + lat, cyclical = c(TRUE, FALSE))),
                 color = "red")

}
\seealso{
\code{\link{DerivatePhysical}}

Other meteorology functions: \code{\link{DerivatePhysical}},
  \code{\link{EOF}}, \code{\link{FitQsWave}},
  \code{\link{WaveFlux}}
}
\concept{meteorology functions}
